## 变量、作用域和内存问题

### 1. 基本类型和引用类型的值

基本类型值指的是简单的数据段，而引用类型值指的是那些可能由多个值构成的对象

Number, Boolean, String, Undefined 和 Null 是基本数据类型，这五种数据类型是按值访问的，可以直接操作保存在变量中的实际的值

而引用类型的值是保存在内存中的对象，我们在 js 中是想要直接操作内存空间是不允许的，所以我们操作对象的时候，实际上是在操作对象的引用，而不是真实的对象

### 2. 动态的属性

我们可以为一个引用类型的值添加属性，而我们不可以为基本类型的值添加属性，尽管这样做不会导致任何错误

尽管我们可以这样使用：

```js
var a = 'hfm-an'
a.b = 1
```

但是我们后续访问这个 a.b 的时候实际上会返回 undefined

因为在执行属性赋值语句 `a.b = 1` 的时候，js 引擎会以 a 新建一个临时的 String 对象实例，然后执行 a.b 这条赋值语句，而 b 属性是设置在那个临时的 String 实例上了，在执行完成后，那个临时 String 对象被销毁，所以 b 属性也就被销毁了

所以我们总结起来，就是只能给引用类型添加属性，而不能给基本属性添加类型

### 3. 没有块级作用域

##### 之前有想过一个问题：

我们知道这种情况下，会打印出10次10

```js
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i)
    })
}
```

而修正的方法，则是把 var 改成 let

```js
for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i)
    })
}
```

今天具体去看了下到底是为什么

es6 新增了 let 之后，也为 for 循环新增了一条规则

如果说在 for 循环的声明语句中使用了 let 关键字，则会在每次 for 循环中，都新建一个词法环境，把 let 声明的变量，拷贝一份到每次循环的词法环境中，也就是说在每次 for 循环块里，我们访问的都是一个 i 的副本，记作 _i，而且因为 let 拥有块级作用域，这个作用域在代码执行完成后，因为 setTimeout 的函数保留有这个这个 _i 的引用，所以最后打印的就是正确的 0, 1, 2, 3, ....

可以理解为：

```js
// 初始声明
{ 
    let i;
    i = 0;
    // 这里声明一个全局 __status, 用来保存 i 上次循环之后的值
    __status = { i };
}

// 第一次循环体
{
    // 每次是第一个代码块中的 i 的一个副本
    // 这个副本 i 与原始的值相同，但是是这个代码块中的局部变量
    let { i } = __status
    if (i < 10) {
        setTimeout(() => console.log(i))
    }
    // 再把现在这个作用域中的 i，赋值给第一个代码块中的 i
    // 相当于当前循环执行完毕之后，把代码块中的 i 副本的值，更新到最原始的那个 i 上
    __status = { i }
}

// 第二次循环体
{
    // 再取一个副本出来
    let { i } = __status
    // 副本 ++
    i ++
    if (i < 10) {
        setTimeout(() => console.log(i))
    }
    // 副本 i 的值赋值给原始 i
    __status = { i }
}

// ...
```