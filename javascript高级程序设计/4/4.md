## 变量、作用域和内存问题

### 1. 基本类型和引用类型的值

基本类型值指的是简单的数据段，而引用类型值指的是那些可能由多个值构成的对象

Number, Boolean, String, Undefined 和 Null 是基本数据类型，这五种数据类型是按值访问的，可以直接操作保存在变量中的实际的值

而引用类型的值是保存在内存中的对象，我们在 js 中是想要直接操作内存空间是不允许的，所以我们操作对象的时候，实际上是在操作对象的引用，而不是真实的对象

### 2. 动态的属性

我们可以为一个引用类型的值添加属性，而我们不可以为基本类型的值添加属性，尽管这样做不会导致任何错误

尽管我们可以这样使用：

```js
var a = 'hfm-an'
a.b = 1
```

但是我们后续访问这个 a.b 的时候实际上会返回 undefined

因为在执行属性赋值语句 `a.b = 1` 的时候，js 引擎会以 a 新建一个临时的 String 对象实例，然后执行 a.b 这条赋值语句，而 b 属性是设置在那个临时的 String 实例上了，在执行完成后，那个临时 String 对象被销毁，所以 b 属性也就被销毁了

所以我们总结起来，就是只能给引用类型添加属性，而不能给基本属性添加类型

### 3. 执行环境以及作用域

每个执行环境都有一个与之关联的变量对象。环境中定义的所有变量和函数都保存在这个对象中，虽然我们编写的代码无法访问这个对象，但是解析器在处理数据的时候，会在后台使用它

全局执行环境是最外围的一个执行环境。在 web 浏览器中，全局执行环境被认为是 window 对象。

某个执行环境中的代码执行完毕后，环境刚被销毁，保存在其中的变量和函数也会一起被销毁。

每个函数都有自己的执行环境。当执行刘进入一个函数的时候，函数的环境就会被推入一个环境栈中，函数执行结束后，函数的环境出栈，并销毁

当代码在一个环境中执行的时候，会创建变量对象的一个作用域链。这个作用域链的用处，就是为了保证对执行环境有权访问的变量和函数的有序访问。总结起来其实就是里层的覆盖外层的

```js
var color = 'red'
function changeColor () {
    var color = 'blue'
    console.log(color)
}
```

上面代码的例子，调用 `changeColor` 的话会打印出 blue, 因为内层的 `color` 标识符覆盖了外层的 `color`, 因为标识符的解析是一层一层，从里层向外层寻找的，所以内覆盖外

### 4. 声明变量

使用 `var` 声明的变量，将被自动添加到最近的环境中

但是如果在作用域内没有使用 `var` 声明一个变量，则执行那条语句之后，该变量将会添加到全局环境中

### 5. 垃圾回收

js 常见的有两种 GC 方式，标记清除和引用计数

标记清除是最通用的方式，他的标记过程其实就是作用域访问的过程，当一个变量声明了之后，这个变量则进入当前的执行环境，当执行环境栈退出这个执行环境时，则这个变量退出当前执行环境，此时这个变量被标记为可以回收的内存

引用计数的实现方式，是当变量 B 引用变量 A 的时候，则变量A的引用次数 + 1， 若变量 B 释放了对 A 的引用，此时 A 的引用次数 -1， 此时 A 的引用次数为 0，会被标记为可以回收

但是引用计数的 GC 方式，不可规避的问题就是涉及到循环应用的时候，两个本该被释放的内存的引用次数永远 > 0, 则两个变量永远都不会得到释放，所以标记清除其实更通用一些。。

